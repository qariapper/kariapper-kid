
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kariapper Family Tree ‚Äì Clean 3‚ÄëWay Toggle</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="d3.min.js"></script>
  <style>
    body { margin: 0; font-family: "Segoe UI", sans-serif; }
    h1 { text-align: center; margin: 12px 0; }
    #controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 6px; flex-wrap: wrap; }
    #tree_div { width: 100%; height: calc(100vh - 110px); overflow: auto; }

    .trunk, .branch { fill: none; stroke: #888; stroke-width: 1.5px; stroke-linecap: round; }
    .node-rect { rx: 4; ry: 4; filter: drop-shadow(2px 2px 2px rgba(0,0,0,.15)); stroke: #888; stroke-width: 2px; }
    .deceased { stroke: green !important; }
    /* Tooltip glow + animation */
    .married-text { font-weight: bold; filter: drop-shadow(0 0 2px gold); }
    @keyframes pulse-glow {
      0%   { filter: drop-shadow(0 0 2px gold); }
      50%  { filter: drop-shadow(0 0 5px orange); }
      100% { filter: drop-shadow(0 0 2px gold); }
    }
    .node.married-text.hover-linked text.label {
      animation: pulse-glow 1s infinite;
    }

    .node-text { pointer-events: none; text-anchor: start; dominant-baseline: central; font-size: 15px; }
    .index-dID  { fill: #111; }
    .index-KID  { fill: #e53935; font-weight: bold; }
    .index-KSID { fill: #1565c0; font-weight: bold; }

    .toggle-dID  { color: #222; border-color: #bbb; }
    .toggle-KID  { color: #e53935; border-color: #e53935; }
    .toggle-KSID { color: #1565c0; border-color: #1565c0; }

    .node { cursor: pointer; }
  </style>
</head>
<body>
  <h1>Kariapper Family Tree--a</h1>
  <div id="controls">
    <button id="btnToggleGen3">Toggle Gen‚Äë3</button>
    <button id="btnZoomIn">Ôºã</button>
    <button id="btnZoomOut">Ôºç</button>
    <button id="btnReset">Reset View</button>
    <button id="btnIdxToggle" class="toggle-dID" title="Click to show KID">Kariapper‚ÄëdID</button>
  </div>
  <div id="tree_div">Loading‚Ä¶</div>

  <script>
(async function(){
  const sheetID = '1BE7PJAJs3QxHnOsb1z5cKnGHdjQCR8IksorMcAm7Fx8';
  const initialOpenDepth = 1;
  const charW = 9;
  const leftStub = 16;
  const indexModes = ['dID', 'KID', 'KSID'];
  let idxMode = indexModes[0];
  let gen3Collapsed = true;

  const raw = await fetch(`https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?gid=0&headers=1&tqx=out:json`).then(r => r.text());
  const json = JSON.parse(raw.slice(raw.indexOf('(')+1, raw.lastIndexOf(')')));
  const cols = json.table.cols.map(c => c.label);
  const rows = json.table.rows;
  const col = name => cols.findIndex(h => h.trim().toLowerCase() === name);
  const idIdx = cols.findIndex(h => /\(dID\)$/i.test(h));
  const kidIdx = cols.findIndex(h => /\(KID\)$/i.test(h));
  const ksidIdx = cols.findIndex(h => /\(KSID\)$/i.test(h));
  const genIdx = col('generation');
  const nameIdx = cols.findIndex(h => h.trim() === 'Full Name');
  const spouseIdx = cols.findIndex(h => h.trim().toLowerCase().startsWith('spouse'));
  const genderIdx = col('gender');
  const dodIdx = 12;
  const spouseLinksIdx = col('validspouselinks');
  const commentsIdx = col('comments');
  const btnZoomIn  = d3.select('#btnZoomIn');
  const btnZoomOut = d3.select('#btnZoomOut');
  const btnReset   = d3.select('#btnReset');
  btnZoomIn .on('click',()=>svg.transition().call(zoom.scaleBy,1.25));
  btnZoomOut.on('click',()=>svg.transition().call(zoom.scaleBy,0.8));
  btnReset  .on('click',()=>svg.transition().call(zoom.transform,d3.zoomIdentity));

  const fatherNameIdx = col('father name');
  const motherNameIdx = col('mother name');
  const flat = rows.map(r => {
    const get = i => (i >= 0 && r.c[i]) ? r.c[i].v : '';
    const id = get(idIdx);
    return {
      id,
      kid: get(kidIdx),
      ksid: get(ksidIdx),
      name: get(nameIdx),
      gen: +get(genIdx),
      spouse: get(spouseIdx),
      gender: get(genderIdx).toLowerCase().startsWith('f') ? 'f' : 'm',
      dod: get(dodIdx),
      comments: get(commentsIdx),
      spouse_dIDs: get(spouseLinksIdx).split(',').map(s => s.trim()).filter(Boolean),
      parent: id.includes('.') ? id.replace(/\.[^.]+$/, '') : '',
      children: [],
      fatherName: get(fatherNameIdx),
      motherName: get(motherNameIdx)
    };
  }).filter(d => d.id && d.name);

  const byId = Object.fromEntries(flat.map(d => [d.id, d]));
  flat.forEach(d => { if (d.parent && byId[d.parent]) byId[d.parent].children.push(d); });

  // Assign spouse group number to children
  flat.forEach(parent => {
    if (!parent.spouse_dIDs.length) return;

    parent.spouse_dIDs.forEach((spID, i) => {
      const groupNum = i + 1;
      const children = flat.filter(child =>
        child.parent === parent.id &&
        child.comments && child.comments.includes(spID)
      );
      children.forEach(c => c.spouseGroupNum = groupNum);
    });
  });

  // Assign spouse group number to children using father/mother name matching
  flat.forEach(parent => {
    const spouseNames = parent.spouse?.split(',').map(s => s.trim().toLowerCase()) || [];
    if (!spouseNames.length) return;

    flat.forEach(child => {
      if (child.parent === parent.id) {
        const otherParentName = parent.gender === 'm'
          ? child.motherName?.toLowerCase()
          : child.fatherName?.toLowerCase();

        const groupNum = spouseNames.findIndex(name => name === otherParentName);
        if (groupNum >= 0) child.spouseGroupNum = groupNum + 1;
      }
    });
  });

  const rootData = byId['ALK'];
  if (!rootData) return document.getElementById('tree_div').textContent = '‚ùå root ALK not found';

  const marriageMap = {};
  flat.forEach(d => {
    d.spouse_dIDs.forEach(sp => {
      if (byId[sp]) {
        if (!marriageMap[d.id]) marriageMap[d.id] = new Set();
        if (!marriageMap[sp])   marriageMap[sp]   = new Set();
        marriageMap[d.id].add(sp);
        marriageMap[sp].add(d.id);
      }
    });
  });

  const root = d3.hierarchy(rootData, d => d.children);
  root.descendants().forEach(d => { if (d.depth >= initialOpenDepth && d.children) { d._children = d.children; d.children = null; } });

  const svg = d3.select('#tree_div').html('').append('svg').attr('preserveAspectRatio','xMinYMin meet');
  const gZoom = svg.append('g');
  const g = gZoom.append('g');
  const zoom = d3.zoom().scaleExtent([0.5, 2]).on('zoom', e => gZoom.attr('transform', e.transform));
  svg.call(zoom);

  const tooltip = g.append('text').attr('class','tooltip').style('display','none');

  const nodeLabel = d => {
    const icon = d.data.gender === 'f' ? ' ‚ôÄ' : ' ‚ôÇ';
    const index = idxMode === 'KID' && d.data.kid ? d.data.kid :
                  idxMode === 'KSID' && d.data.ksid ? d.data.ksid : d.data.id;
    const prefix = d.data.spouseGroupNum ? d.data.spouseGroupNum + '-' : '';
    return { text: prefix + d.data.name + icon, idx: index };
  };
  const boxWidth = d => Math.max(80, (nodeLabel(d).text + ' ' + nodeLabel(d).idx).length * charW + 20);

  const update = () => {
    const maxLabelChars = d3.max(root.descendants(), d => (nodeLabel(d).text + ' ' + nodeLabel(d).idx).length);
    const hSpacing = Math.max(200, Math.min(500, maxLabelChars * charW + 60));

    d3.tree().nodeSize([40, hSpacing])(root);

    const xs = root.descendants().map(d => d.x);
    const ys = root.descendants().flatMap(d => [d.y, d.y + boxWidth(d) + leftStub]);
    const M = 100;
    svg.attr('viewBox', [0, 0, Math.max(...ys)-Math.min(...ys)+M*2, Math.max(...xs)-Math.min(...xs)+M*2].join(' '));
    g.attr('transform', `translate(${M - Math.min(...ys)},${M - Math.min(...xs)})`);

    const nodes = g.selectAll('g.node').data(root.descendants(), d => d.data.id)
      .join(enter => {
        const n = enter.append('g').attr('class','node').on('click', (_,d) => toggleNode(d));
        n.append('rect');
        n.append('text').attr('class','node-text label');
        n.append('text').attr('class','node-text index');
        return n;
      });

    nodes.attr('transform', d => `translate(${d.parent ? d.y + leftStub : d.y},${d.x})`);
    
  nodes.each(function(d){
    const sel = d3.select(this);
    const lab = nodeLabel(d);
    const w = boxWidth(d);

    // üßπ Remove all previous rects and texts
    sel.selectAll('rect').remove();
    sel.selectAll('text').remove();

    // Gender background
    sel.append('rect')
      .attr('x', 0)
      .attr('y', -12)
      .attr('width', w)
      .attr('height', 24)
      .attr('rx', 4)
      .attr('ry', 4)
      //.attr('stroke', '#888')
      .attr('stroke-width', 2)
      .attr('fill', d.data.gender === 'f' ? '#fbd3e0' :
                    d.data.gender === 'm' ? '#d0e4f7' : '#eee')
      .attr('class', () => {
        let cls = 'node-rect';
        if (d.data.dod) cls += ' deceased';
        return cls;
      });

    // Generation overlay (optional, layered on top)
    const genOverlay = d.data.gen === 1 ? '#eceff4'
                    : d.data.gen === 2 ? '#e5e9f0'
                    : d.data.gen === 3 ? '#d8dee9'
                    : '';
    if (genOverlay) {
      sel.append('rect')
        .attr('class', 'gen-overlay')
        .attr('x', 0)
        .attr('y', -12)
        .attr('width', w)
        .attr('height', 24)
        .attr('rx', 4)
        .attr('ry', 4)
        .attr('fill', genOverlay)
        .lower();
    }

    // Append texts fresh
    sel.append('text')
      .attr('class','node-text label')
      .attr('x', 10)
      .attr('y', 0)
      .text(lab.text);

    sel.append('text')
      .attr('class', `node-text index index-${idxMode}`)
      .attr('x', 10 + lab.text.length * charW)
      .attr('y', 0)
      .text(lab.idx ? ' ' + lab.idx : '');
  }); 


    const nodeById = {};
    nodes.each(function(d){
      nodeById[d.data.id] = {
        rect: d3.select(this).select('rect'),
        label: d3.select(this).select('text.label'),
        group: d3.select(this)
      };
    });

    nodes.select('text.label')
        .attr('x', 10);

    nodes.select('text.index')
        .attr('x', d => {
          const lab = nodeLabel(d);
          return 10 + lab.text.length * charW;
        });

    // Build trunk + stub data
    const trunks = [], stubs = [];
    root.descendants().forEach(p => {
      if (!p.children || !p.children.length) return;
      const trunkX = d3.min(p.children, c => c.y);
      const childYs = p.children.map(c => c.x);
      const y0 = d3.min(childYs), y1 = d3.max(childYs);
      if (y0 === y1) {
        const xs = p.children.map(c => c.y);
        trunks.push({ h: true, x0: Math.min(...xs), x1: Math.max(...xs), y: y0 });
      } else {
        trunks.push({ h: false, x: trunkX, y0, y1 });
      }
      const parentRight = p.y + boxWidth(p) + (p.depth > 0 ? leftStub : 0);
      stubs.push({ x0: parentRight, x1: trunkX, y: p.x });
    });
    root.descendants().forEach(n => {
      if (n.depth > 0) stubs.push({ x0: n.y, x1: n.y + leftStub, y: n.x });
    });

    // Draw trunks
    g.selectAll('path.trunk').data(trunks, d => d.h ? `h-${d.x0}-${d.x1}-${d.y}` : `v-${d.x}-${d.y0}-${d.y1}`)
      .join(enter => enter.append('path').attr('class', 'trunk'))
      .attr('d', d => d.h ? `M${d.x0},${d.y}H${d.x1}` : `M${d.x},${d.y0}V${d.y1}`);

    // Draw stubs
    g.selectAll('path.stub').data(stubs)
      .join(enter => enter.append('path').attr('class', 'trunk stub'))
      .attr('d', d => `M${d.x0},${d.y}H${d.x1}`);


    g.selectAll('g.node').classed('married-text', false).classed('hover-linked', false);

    Object.entries(marriageMap).forEach(([id, partners]) => {
      if (partners.size > 0 && nodeById[id]) {
        nodeById[id].group.classed('married-text', true);
      }
    });

    nodes.on('mouseover', function(_, d){
      const ids = new Set([d.data.id, ...(marriageMap[d.data.id] || [])]);
      ids.forEach(id => {
        const n = nodeById[id];
        if (n) n.group.classed('hover-linked', true);
      });
      const t = d.data.spouse?.trim() ? `Spouse(s): ${d.data.spouse}` : d.data.comments;
      if (t) tooltip.text(t).attr('x', d.y + leftStub + 5).attr('y', d.x - 18).style('display','block');
    }).on('mouseout', function(_, d){
      const ids = new Set([d.data.id, ...(marriageMap[d.data.id] || [])]);
      ids.forEach(id => {
        const n = nodeById[id];
        if (n) n.group.classed('hover-linked', false);
      });
      tooltip.style('display', 'none');
    });
  };

  function toggleNode(d){
    if (d.children) { d._children = d.children; d.children = null; }
    else if (d._children) { d.children = d._children; d._children = null; }
    update();
  }

  d3.select('#btnToggleGen3').on('click', () => {
    root.descendants().forEach(n => {
      if (n.depth === 1) {
        if (gen3Collapsed) {
          // expand all Gen-3 if they have _children
          if (n._children) {
            n.children = n._children;
            n._children = null;
          }
        } else {
          // collapse all Gen-3 regardless of current state
          if (n.children) {
            n._children = n.children;
            n.children = null;
          }
        }
      }
    });
    gen3Collapsed = !gen3Collapsed;
    update();
  });

  d3.select('#btnIdxToggle').on('click', () => {
    const next = (indexModes.indexOf(idxMode) + 1) % indexModes.length;
    idxMode = indexModes[next];
    const btn = d3.select('#btnIdxToggle');
    btn.attr('class', `toggle-${idxMode}`);
    btn.text(`Kariapper-${idxMode}`);
    btn.attr('title', `Click to show ${indexModes[(next + 1) % indexModes.length]}`);
    update();
  });

  update();
})();
  </script>
</body>
</html>
